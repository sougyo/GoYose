<!--
  Copyright 2026 sougyo

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>囲碁ヨセ研究</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Segoe UI', sans-serif;
  background: #f0f0f0;
  overflow: hidden;
  height: 100vh;
  display: flex;
  flex-direction: row;
}

#toolbar {
  background: #333;
  color: #fff;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-shrink: 0;
  z-index: 100;
  flex-wrap: wrap;
}

#toolbar button {
  background: #555;
  color: #fff;
  border: none;
  padding: 6px 14px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

#toolbar button:hover { background: #777; }
#toolbar button.active { background: #e8a735; color: #333; }

#toolbar label {
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 4px;
}

#toolbar input[type="number"] {
  width: 50px;
  padding: 4px;
  border: none;
  border-radius: 3px;
  text-align: center;
}

#toolbar .separator {
  width: 1px;
  height: 24px;
  background: #666;
}

#right-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* --- Sidebar --- */
#sidebar {
  width: 200px;
  background: #2b2b2b;
  color: #ddd;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  z-index: 90;
  border-right: 1px solid #444;
}

#sidebar-header {
  padding: 8px 10px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #444;
  font-size: 13px;
  font-weight: bold;
  color: #aaa;
}

#sidebar-header button {
  background: #555;
  color: #fff;
  border: none;
  padding: 3px 10px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
}

#sidebar-header button:hover { background: #777; }

#tree-list {
  flex: 1;
  overflow-y: auto;
  list-style: none;
}

#tree-list li {
  padding: 8px 10px;
  cursor: pointer;
  border-bottom: 1px solid #393939;
  font-size: 13px;
  display: flex;
  align-items: center;
  gap: 6px;
}

#tree-list li:hover { background: #3a3a3a; }
#tree-list li.active { background: #4a4a2a; color: #fff; }

#tree-list li .tree-title-text {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#tree-list li .tree-title-input {
  flex: 1;
  background: #444;
  color: #fff;
  border: 1px solid #e8a735;
  border-radius: 3px;
  padding: 2px 4px;
  font-size: 13px;
  outline: none;
}

#tree-list li .btn-delete-tree {
  background: none;
  border: none;
  color: #888;
  cursor: pointer;
  font-size: 14px;
  padding: 0 2px;
  line-height: 1;
}

#tree-list li .btn-delete-tree:hover { color: #e55; }

#sidebar-footer {
  padding: 8px 10px;
  border-top: 1px solid #444;
  display: flex;
  gap: 6px;
}

#sidebar-footer button {
  flex: 1;
  background: #555;
  color: #fff;
  border: none;
  padding: 5px 0;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
}

#sidebar-footer button:hover { background: #777; }

/* --- Canvas area --- */
#canvas-area {
  flex: 1;
  position: relative;
  overflow: hidden;
  cursor: grab;
}

#canvas-area.panning { cursor: grabbing; }

#connection-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}

.node-card {
  position: absolute;
  background: #fff;
  border: 2px solid #ccc;
  border-radius: 8px;
  padding: 8px;
  cursor: grab;
  z-index: 10;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  user-select: none;
  min-width: 80px;
}

.node-card:active { cursor: grabbing; }
.node-card.selected { border-color: #e8a735; box-shadow: 0 0 0 3px rgba(232,167,53,0.3); }

.node-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
  font-size: 12px;
  color: #666;
}

.node-header .btn-copy {
  background: #e8e8e8;
  border: 1px solid #ccc;
  border-radius: 3px;
  padding: 1px 6px;
  cursor: pointer;
  font-size: 11px;
  color: #444;
  line-height: 1.4;
}

.node-header .btn-copy:hover { background: #d0d0d0; }

.node-board-canvas {
  display: block;
  margin: 0 auto 6px;
  cursor: crosshair;
  border-radius: 2px;
}

.node-score {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  font-size: 13px;
}

.node-score label { color: #666; }

.node-score input {
  width: 60px;
  padding: 3px 4px;
  border: 1px solid #ccc;
  border-radius: 3px;
  text-align: center;
  font-size: 13px;
}

.node-score .computed {
  font-weight: bold;
  color: #2a7d2a;
  font-size: 15px;
}

#instructions {
  position: absolute;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.7);
  color: #fff;
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  z-index: 50;
  pointer-events: none;
  white-space: nowrap;
}

/* Hidden file input */
#import-input { display: none; }
</style>
</head>
<body>

<div id="sidebar">
  <div id="sidebar-header">
    <span>ツリー一覧</span>
    <button id="btn-new-tree">+ 新規</button>
  </div>
  <ul id="tree-list"></ul>
  <div id="sidebar-footer">
    <button id="btn-export">エクスポート</button>
    <button id="btn-import">インポート</button>
  </div>
</div>

<div id="right-panel">
  <div id="toolbar">
    <button id="btn-add">+ ノード追加</button>
    <label>盤サイズ: <input type="number" id="board-size" value="9" min="3" max="19"></label>
    <div class="separator"></div>
    <button id="btn-connect">接続 (2ノード選択)</button>
    <button id="btn-delete">削除</button>
    <div class="separator"></div>
    <button id="btn-calc">計算</button>
  </div>
  <div id="canvas-area">
    <canvas id="connection-canvas"></canvas>
    <div id="instructions">ノードを追加して木構造を構築 → 葉ノードに目数を入力 → 計算ボタンで伝播</div>
  </div>
</div>

<input type="file" id="import-input" accept=".json">

<script>
(function() {
  // =============================================
  // Multi-tree state
  // =============================================
  let trees = [];        // array of tree data objects
  let activeTreeId = null;
  let nextTreeId = 1;

  // Current tree's live state (mirrors the active tree)
  let nodes = [];
  let nextNodeId = 1;
  let selectedIds = [];
  let panX = 0, panY = 0;
  let zoom = 1;
  const ZOOM_MIN = 0.2, ZOOM_MAX = 3;

  const canvasArea = document.getElementById('canvas-area');
  const connCanvas = document.getElementById('connection-canvas');
  const connCtx = connCanvas.getContext('2d');
  const treeListEl = document.getElementById('tree-list');

  // =============================================
  // Tree serialization helpers
  // =============================================
  function serializeCurrentTree() {
    // Read score from leaf inputs before saving
    for (const n of nodes) {
      if (n.childIds.length === 0 && n.el) {
        const inp = n.el.querySelector('.score-input');
        if (inp) n.score = inp.value !== '' ? parseFloat(inp.value) : null;
      }
    }
    return {
      nodes: nodes.map(n => ({
        id: n.id,
        x: n.x, y: n.y,
        boardSize: n.boardSize,
        board: n.board,
        score: n.score,
        childIds: [...n.childIds],
        parentId: n.parentId,
      })),
      nextNodeId,
      panX, panY, zoom,
    };
  }

  function saveActiveTree() {
    const tree = trees.find(t => t.id === activeTreeId);
    if (tree) tree.data = serializeCurrentTree();
  }

  function clearCanvas() {
    for (const n of nodes) { if (n.el) n.el.remove(); }
    nodes = [];
    nextNodeId = 1;
    selectedIds = [];
    panX = 0; panY = 0; zoom = 1;
    drawConnections();
  }

  function loadTree(treeId) {
    if (activeTreeId !== null) saveActiveTree();
    clearCanvas();
    activeTreeId = treeId;
    const tree = trees.find(t => t.id === treeId);
    if (!tree) return;
    const d = tree.data;
    nextNodeId = d.nextNodeId || 1;
    panX = d.panX || 0;
    panY = d.panY || 0;
    zoom = d.zoom || 1;
    // Recreate node objects (without DOM yet)
    const nodeMap = {};
    for (const nd of d.nodes) {
      const node = {
        id: nd.id,
        x: nd.x, y: nd.y,
        boardSize: nd.boardSize,
        board: nd.board.map(row => [...row]),
        score: nd.score,
        childIds: [...nd.childIds],
        parentId: nd.parentId,
        el: null,
        boardCanvas: null,
      };
      nodes.push(node);
      nodeMap[node.id] = node;
    }
    // Render all
    for (const node of nodes) renderNode(node);
    drawConnections();
    renderTreeList();
  }

  // =============================================
  // Tree list management
  // =============================================
  function addNewTree(title) {
    const tree = {
      id: nextTreeId++,
      title: title || 'Untitled',
      data: { nodes: [], nextNodeId: 1, panX: 0, panY: 0, zoom: 1 },
    };
    trees.push(tree);
    loadTree(tree.id);
    return tree;
  }

  function deleteTree(treeId) {
    if (trees.length <= 1) return; // keep at least one
    trees = trees.filter(t => t.id !== treeId);
    if (activeTreeId === treeId) {
      loadTree(trees[0].id);
    } else {
      renderTreeList();
    }
  }

  function renderTreeList() {
    treeListEl.innerHTML = '';
    for (const tree of trees) {
      const li = document.createElement('li');
      if (tree.id === activeTreeId) li.classList.add('active');

      // Title display
      const titleSpan = document.createElement('span');
      titleSpan.className = 'tree-title-text';
      titleSpan.textContent = tree.title;
      li.appendChild(titleSpan);

      // Delete button
      const delBtn = document.createElement('button');
      delBtn.className = 'btn-delete-tree';
      delBtn.textContent = '\u00d7';
      delBtn.title = '削除';
      li.appendChild(delBtn);

      // Click to switch
      titleSpan.addEventListener('click', () => {
        if (tree.id === activeTreeId) return;
        loadTree(tree.id);
      });

      // Double-click to rename
      titleSpan.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        startRename(li, tree);
      });

      // Delete
      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (trees.length <= 1) { alert('最後のツリーは削除できません'); return; }
        deleteTree(tree.id);
      });

      treeListEl.appendChild(li);
    }
  }

  function startRename(li, tree) {
    const existing = li.querySelector('.tree-title-input');
    if (existing) return;
    const titleSpan = li.querySelector('.tree-title-text');
    titleSpan.style.display = 'none';

    const input = document.createElement('input');
    input.className = 'tree-title-input';
    input.value = tree.title;
    li.insertBefore(input, titleSpan);
    input.focus();
    input.select();

    function commit() {
      const val = input.value.trim();
      tree.title = val || 'Untitled';
      input.remove();
      titleSpan.style.display = '';
      titleSpan.textContent = tree.title;
    }
    input.addEventListener('blur', commit);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') input.blur();
      if (e.key === 'Escape') { input.value = tree.title; input.blur(); }
    });
  }

  // =============================================
  // Export / Import
  // =============================================
  function exportData() {
    saveActiveTree();
    const data = {
      version: 1,
      nextTreeId,
      trees: trees.map(t => ({ id: t.id, title: t.title, data: t.data })),
      activeTreeId,
    };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'goyose-data.json';
    a.click();
    URL.revokeObjectURL(url);
  }

  function importData(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if (!data.trees || !Array.isArray(data.trees)) throw new Error('invalid format');
        // Clear current state
        clearCanvas();
        trees = data.trees.map(t => ({
          id: t.id,
          title: t.title || 'Untitled',
          data: t.data,
        }));
        nextTreeId = data.nextTreeId || (Math.max(...trees.map(t => t.id)) + 1);
        const targetId = data.activeTreeId || trees[0].id;
        activeTreeId = null; // reset so loadTree works
        loadTree(targetId);
      } catch (err) {
        alert('ファイルの読み込みに失敗しました: ' + err.message);
      }
    };
    reader.readAsText(file);
  }

  // =============================================
  // Resize connection canvas
  // =============================================
  function resizeConnCanvas() {
    connCanvas.width = canvasArea.clientWidth;
    connCanvas.height = canvasArea.clientHeight;
    drawConnections();
  }
  window.addEventListener('resize', resizeConnCanvas);
  requestAnimationFrame(resizeConnCanvas);

  // =============================================
  // Node CRUD
  // =============================================
  function createNode(x, y, boardSize) {
    const board = [];
    for (let r = 0; r < boardSize; r++) {
      board.push(new Array(boardSize).fill(0));
    }
    const node = {
      id: nextNodeId++,
      x, y,
      boardSize,
      board,
      score: null,
      childIds: [],
      parentId: null,
      el: null,
      boardCanvas: null,
    };
    nodes.push(node);
    renderNode(node);
    return node;
  }

  function copyAsChild(parentNode) {
    const child = createNode(parentNode.x + 60, parentNode.y + 250, parentNode.boardSize);
    for (let r = 0; r < parentNode.boardSize; r++) {
      for (let c = 0; c < parentNode.boardSize; c++) {
        child.board[r][c] = parentNode.board[r][c];
      }
    }
    drawBoard(child);
    connectNodes(parentNode.id, child.id);
    return child;
  }

  function findNode(id) {
    return nodes.find(n => n.id === id);
  }

  function removeNode(id) {
    const node = findNode(id);
    if (!node) return;
    if (node.parentId !== null) {
      const parent = findNode(node.parentId);
      if (parent) parent.childIds = parent.childIds.filter(c => c !== id);
    }
    for (const cid of node.childIds) {
      const child = findNode(cid);
      if (child) child.parentId = null;
    }
    if (node.el) node.el.remove();
    nodes = nodes.filter(n => n.id !== id);
    selectedIds = selectedIds.filter(s => s !== id);
    drawConnections();
  }

  function connectNodes(parentId, childId) {
    if (parentId === childId) return;
    const parent = findNode(parentId);
    const child = findNode(childId);
    if (!parent || !child) return;
    if (isAncestor(childId, parentId)) return;
    if (child.parentId !== null) {
      const oldParent = findNode(child.parentId);
      if (oldParent) oldParent.childIds = oldParent.childIds.filter(c => c !== childId);
    }
    child.parentId = parentId;
    if (!parent.childIds.includes(childId)) parent.childIds.push(childId);
    updateNodeScoreUI(parent);
    updateNodeScoreUI(child);
    drawConnections();
  }

  function isAncestor(ancestorId, nodeId) {
    let cur = findNode(nodeId);
    while (cur) {
      if (cur.id === ancestorId) return true;
      cur = cur.parentId !== null ? findNode(cur.parentId) : null;
    }
    return false;
  }

  // =============================================
  // Render Node DOM
  // =============================================
  function renderNode(node) {
    const card = document.createElement('div');
    card.className = 'node-card';
    card.dataset.nodeId = node.id;
    card.style.left = (node.x * zoom + panX) + 'px';
    card.style.top = (node.y * zoom + panY) + 'px';
    card.style.transform = 'scale(' + zoom + ')';
    card.style.transformOrigin = '0 0';

    // Header
    const header = document.createElement('div');
    header.className = 'node-header';
    header.innerHTML = `<span>Node ${node.id}</span><button class="btn-copy" title="盤面をコピーして子ノードを作成">CP</button><span>${node.boardSize}x${node.boardSize}</span>`;
    const copyBtn = header.querySelector('.btn-copy');
    copyBtn.addEventListener('mousedown', e => e.stopPropagation());
    copyBtn.addEventListener('click', (e) => { e.stopPropagation(); copyAsChild(node); });
    card.appendChild(header);

    // Board canvas
    const cellSize = node.boardSize <= 9 ? 24 : (node.boardSize <= 13 ? 18 : 14);
    const padding = cellSize;
    const canvasSize = cellSize * (node.boardSize - 1) + padding * 2;
    const bc = document.createElement('canvas');
    bc.className = 'node-board-canvas';
    bc.width = canvasSize;
    bc.height = canvasSize;
    card.appendChild(bc);
    node.boardCanvas = bc;

    // Score area
    const scoreDiv = document.createElement('div');
    scoreDiv.className = 'node-score';
    const isLeaf = node.childIds.length === 0;
    if (isLeaf) {
      scoreDiv.innerHTML = `<label>目数:</label><input type="number" step="0.5" class="score-input" value="${node.score !== null ? node.score : ''}">`;
      const inp = scoreDiv.querySelector('input');
      inp.addEventListener('change', () => {
        node.score = inp.value !== '' ? parseFloat(inp.value) : null;
      });
      inp.addEventListener('mousedown', e => e.stopPropagation());
      inp.addEventListener('click', e => e.stopPropagation());
    } else {
      scoreDiv.innerHTML = `<label>目数:</label><span class="computed">${node.score !== null ? node.score.toFixed(2) : '—'}</span>`;
    }
    card.appendChild(scoreDiv);
    node.el = card;

    // Board click
    bc.addEventListener('click', (e) => {
      const rect = bc.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const col = Math.round((mx - padding) / cellSize);
      const row = Math.round((my - padding) / cellSize);
      if (col >= 0 && col < node.boardSize && row >= 0 && row < node.boardSize) {
        node.board[row][col] = (node.board[row][col] + 1) % 3;
        drawBoard(node);
      }
    });

    // Selection
    card.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'INPUT') return;
      handleSelect(node.id, e);
    });

    // Drag
    setupDrag(card, node);

    canvasArea.appendChild(card);
    drawBoard(node);
  }

  function updateNodeScoreUI(node) {
    if (!node || !node.el) return;
    const scoreDiv = node.el.querySelector('.node-score');
    const isLeaf = node.childIds.length === 0;
    if (isLeaf) {
      if (!scoreDiv.querySelector('input')) {
        scoreDiv.innerHTML = `<label>目数:</label><input type="number" step="0.5" class="score-input" value="${node.score !== null ? node.score : ''}">`;
        const inp = scoreDiv.querySelector('input');
        inp.addEventListener('change', () => {
          node.score = inp.value !== '' ? parseFloat(inp.value) : null;
        });
        inp.addEventListener('mousedown', e => e.stopPropagation());
        inp.addEventListener('click', e => e.stopPropagation());
      }
    } else {
      scoreDiv.innerHTML = `<label>目数:</label><span class="computed">${node.score !== null ? node.score.toFixed(2) : '—'}</span>`;
    }
  }

  // =============================================
  // Draw Board
  // =============================================
  function drawBoard(node) {
    const bc = node.boardCanvas;
    const ctx = bc.getContext('2d');
    const bs = node.boardSize;
    const cellSize = bs <= 9 ? 24 : (bs <= 13 ? 18 : 14);
    const padding = cellSize;

    ctx.fillStyle = '#e8c36a';
    ctx.fillRect(0, 0, bc.width, bc.height);

    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    for (let i = 0; i < bs; i++) {
      const p = padding + i * cellSize;
      ctx.beginPath(); ctx.moveTo(padding, p); ctx.lineTo(padding + (bs - 1) * cellSize, p); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p, padding); ctx.lineTo(p, padding + (bs - 1) * cellSize); ctx.stroke();
    }

    const starPoints = getStarPoints(bs);
    for (const [sr, sc] of starPoints) {
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(padding + sc * cellSize, padding + sr * cellSize, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    const stoneR = cellSize * 0.42;
    for (let r = 0; r < bs; r++) {
      for (let c = 0; c < bs; c++) {
        const v = node.board[r][c];
        if (v === 0) continue;
        const cx = padding + c * cellSize;
        const cy = padding + r * cellSize;
        ctx.beginPath();
        ctx.arc(cx, cy, stoneR, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? '#111' : '#eee';
        ctx.fill();
        ctx.strokeStyle = v === 1 ? '#000' : '#aaa';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
  }

  function getStarPoints(size) {
    if (size < 7) return [];
    const pts = [];
    const edge = size <= 9 ? 2 : 3;
    const mid = Math.floor(size / 2);
    const positions = [edge, size - 1 - edge];
    if (size % 2 === 1) positions.splice(1, 0, mid);
    for (const r of positions) {
      for (const c of positions) {
        pts.push([r, c]);
      }
    }
    return pts;
  }

  // =============================================
  // Reposition / Drag / Selection
  // =============================================
  function repositionAll() {
    for (const n of nodes) {
      if (n.el) {
        n.el.style.left = (n.x * zoom + panX) + 'px';
        n.el.style.top = (n.y * zoom + panY) + 'px';
        n.el.style.transform = 'scale(' + zoom + ')';
        n.el.style.transformOrigin = '0 0';
      }
    }
    drawConnections();
  }

  function setupDrag(card, node) {
    let dragging = false;
    let offX, offY;
    card.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'CANVAS') return;
      dragging = true;
      offX = e.clientX - (node.x * zoom + panX);
      offY = e.clientY - (node.y * zoom + panY);
      card.style.zIndex = 20;
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      node.x = (e.clientX - offX - panX) / zoom;
      node.y = (e.clientY - offY - panY) / zoom;
      card.style.left = (node.x * zoom + panX) + 'px';
      card.style.top = (node.y * zoom + panY) + 'px';
      drawConnections();
    });
    window.addEventListener('mouseup', () => {
      if (dragging) { dragging = false; card.style.zIndex = 10; }
    });
  }

  function handleSelect(id, e) {
    if (e && e.target.tagName === 'CANVAS') return;
    const idx = selectedIds.indexOf(id);
    if (e && e.ctrlKey) {
      if (idx >= 0) selectedIds.splice(idx, 1);
      else selectedIds.push(id);
    } else {
      if (idx >= 0 && selectedIds.length === 1) selectedIds = [];
      else selectedIds = [id];
    }
    updateSelectionUI();
  }

  function updateSelectionUI() {
    for (const n of nodes) {
      if (n.el) n.el.classList.toggle('selected', selectedIds.includes(n.id));
    }
  }

  // =============================================
  // Draw Connections
  // =============================================
  function drawConnections() {
    connCtx.clearRect(0, 0, connCanvas.width, connCanvas.height);
    connCtx.strokeStyle = '#555';
    connCtx.lineWidth = 2;
    connCtx.fillStyle = '#555';

    for (const node of nodes) {
      if (node.parentId === null) continue;
      const parent = findNode(node.parentId);
      if (!parent || !parent.el || !node.el) continue;

      const pr = parent.el.getBoundingClientRect();
      const cr = node.el.getBoundingClientRect();
      const ar = canvasArea.getBoundingClientRect();

      const px = pr.left + pr.width / 2 - ar.left;
      const py = pr.top + pr.height - ar.top;
      const cx = cr.left + cr.width / 2 - ar.left;
      const cy = cr.top - ar.top;

      connCtx.beginPath();
      connCtx.moveTo(px, py);
      connCtx.lineTo(cx, cy);
      connCtx.stroke();

      const angle = Math.atan2(cy - py, cx - px);
      const arrLen = 10;
      connCtx.beginPath();
      connCtx.moveTo(cx, cy);
      connCtx.lineTo(cx - arrLen * Math.cos(angle - 0.4), cy - arrLen * Math.sin(angle - 0.4));
      connCtx.lineTo(cx - arrLen * Math.cos(angle + 0.4), cy - arrLen * Math.sin(angle + 0.4));
      connCtx.closePath();
      connCtx.fill();
    }
  }

  // =============================================
  // Calculation
  // =============================================
  function calculate() {
    const visited = new Set();
    const order = [];
    function dfs(id) {
      if (visited.has(id)) return;
      visited.add(id);
      const node = findNode(id);
      if (!node) return;
      for (const cid of node.childIds) dfs(cid);
      order.push(id);
    }
    for (const n of nodes) dfs(n.id);

    for (const id of order) {
      const node = findNode(id);
      if (!node) continue;
      if (node.childIds.length === 0) continue;
      const childScores = node.childIds.map(cid => {
        const c = findNode(cid);
        return c ? c.score : null;
      }).filter(s => s !== null);
      if (childScores.length > 0) {
        node.score = childScores.reduce((a, b) => a + b, 0) / childScores.length;
      } else {
        node.score = null;
      }
      updateNodeScoreUI(node);
    }
  }

  // =============================================
  // Toolbar handlers
  // =============================================
  document.getElementById('btn-add').addEventListener('click', () => {
    const bs = parseInt(document.getElementById('board-size').value) || 9;
    const clamped = Math.max(3, Math.min(19, bs));
    const viewCenterX = (canvasArea.clientWidth / 2 - panX) / zoom;
    const viewCenterY = (canvasArea.clientHeight / 2 - panY) / zoom;
    const x = viewCenterX - 100 + Math.random() * 200;
    const y = viewCenterY - 80 + Math.random() * 160;
    createNode(x, y, clamped);
  });

  document.getElementById('btn-connect').addEventListener('click', () => {
    if (selectedIds.length !== 2) {
      alert('接続するには2つのノードを選択してください (Ctrl+クリック)');
      return;
    }
    connectNodes(selectedIds[0], selectedIds[1]);
    selectedIds = [];
    updateSelectionUI();
  });

  document.getElementById('btn-delete').addEventListener('click', () => {
    if (selectedIds.length === 0) {
      alert('削除するノードを選択してください');
      return;
    }
    for (const id of [...selectedIds]) removeNode(id);
    drawConnections();
  });

  document.getElementById('btn-calc').addEventListener('click', calculate);

  // =============================================
  // Sidebar handlers
  // =============================================
  document.getElementById('btn-new-tree').addEventListener('click', () => {
    const title = prompt('新しいツリーのタイトル:', 'Untitled');
    if (title === null) return; // cancelled
    addNewTree(title.trim() || 'Untitled');
  });

  document.getElementById('btn-export').addEventListener('click', exportData);

  const importInput = document.getElementById('import-input');
  document.getElementById('btn-import').addEventListener('click', () => {
    importInput.click();
  });
  importInput.addEventListener('change', () => {
    if (importInput.files.length > 0) {
      importData(importInput.files[0]);
      importInput.value = '';
    }
  });

  // =============================================
  // Pan (background drag) + deselect
  // =============================================
  {
    let panning = false;
    let panStartX, panStartY, panStartPanX, panStartPanY;
    let moved = false;

    canvasArea.addEventListener('mousedown', (e) => {
      if (e.target !== canvasArea && e.target !== connCanvas) return;
      panning = true;
      moved = false;
      panStartX = e.clientX;
      panStartY = e.clientY;
      panStartPanX = panX;
      panStartPanY = panY;
      canvasArea.classList.add('panning');
      e.preventDefault();
    });

    window.addEventListener('mousemove', (e) => {
      if (!panning) return;
      const dx = e.clientX - panStartX;
      const dy = e.clientY - panStartY;
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) moved = true;
      panX = panStartPanX + dx;
      panY = panStartPanY + dy;
      repositionAll();
    });

    window.addEventListener('mouseup', () => {
      if (!panning) return;
      panning = false;
      canvasArea.classList.remove('panning');
      if (!moved) {
        selectedIds = [];
        updateSelectionUI();
      }
    });
  }

  // =============================================
  // Zoom (mouse wheel)
  // =============================================
  canvasArea.addEventListener('wheel', (e) => {
    e.preventDefault();
    const ar = canvasArea.getBoundingClientRect();
    // Mouse position relative to canvas-area
    const mx = e.clientX - ar.left;
    const my = e.clientY - ar.top;
    // World position under the cursor before zoom
    const wx = (mx - panX) / zoom;
    const wy = (my - panY) / zoom;
    // Apply zoom
    const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
    zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom * factor));
    // Adjust pan so that the world point under cursor stays fixed
    panX = mx - wx * zoom;
    panY = my - wy * zoom;
    repositionAll();
  }, { passive: false });

  // =============================================
  // Initialize with one default tree
  // =============================================
  addNewTree('Untitled');
})();
</script>
</body>
</html>
